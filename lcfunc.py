# serial communication from: https://github.com/Swida-Alba/visual-behavior

import serial
import serial.tools.list_ports
import platform
import datetime
import time
import os
import numpy as np
import pandas as pd
import re
import threading


from collections import defaultdict

# functions
def SetUpSerialPort(board_type='Arduino Uno', **kwargs):
    # modified from LoomingFunc.py
    current_os = platform.system()
    Port = ''
    port_list = list(serial.tools.list_ports.comports())
    port_names = [None]*len(port_list)
    port_num = 0
    ser = ''
    
    for i, port in enumerate(port_list):
        port_name = port.device
        port_names[i] = port_name
        if current_os == 'Windows':
            if port.description.find(board_type) != -1:
                port_num += 1
                Port = port_name
        elif current_os == 'Darwin' or current_os == 'Linux':
            if board_type != 'Arduino':
                board_type = 'Arduino'
                print('Detailed Arduino board cannot be recognized on Mac or Linux. Searching for all "Arduino" boards.')
            if port.manufacturer != None and port.manufacturer.find(board_type) != -1:
                port_num += 1
                Port = port_name
    if port_num == 1:
        print('\n{} is found on {}'.format(board_type,Port))
        answer = input('\nDo you confirm using this port? (Y/n): ')
        if not (answer == 'Y' or answer == 'y'):
            raise ValueError('Port is not confirmed.')
        print('\nBuilding serial connection...')
        ser = serial.Serial(port=Port,**kwargs)
        time.sleep(2)
    elif port_num > 1:
        raise ValueError('More than one {} is connected'.format(board_type))
    else:
        print('\n\033[33mNo {} is connected.\nSerial communication is unavailable.\033[0m\n'.format(board_type))
    return ser

def ClearSerialBuffer(ser, print_flag = False):
    '''check and clear the serial buffer'''
    # modified from LoomingFunc.py
    if not ser:
        return
    else:
        lineNum = 0
        while ser.inWaiting() > 0:
            fb = ser.readline().decode('utf-8').strip()
            lineNum += 1
            print(f'\033[30mCleared serial buffer -- line {lineNum}: {fb}\033[0m')
        if lineNum == 0 and print_flag:
            print('No info in serial buffer.')
        return 0
    
def CheckEmptyDataInMiddle(protocol_df):
    # generated by GPT 4o
    columns_with_empty_in_middle = []
    
    for col in protocol_df.columns:
        data = protocol_df[col]
        
        first_non_null_idx = data.first_valid_index()
        last_non_null_idx = data.last_valid_index()
        
        # if starts with nan values but has non-nan values in the middle
        if first_non_null_idx != 0 and first_non_null_idx is not None:
            columns_with_empty_in_middle.append(col)
            continue
        
        # if nan values in the middle
        if first_non_null_idx is not None and last_non_null_idx is not None:
            if data[first_non_null_idx:last_non_null_idx].isnull().any():
                columns_with_empty_in_middle.append(col)
    
    if columns_with_empty_in_middle:
        raise ValueError(f'The following columns contain empty data in the middle: {columns_with_empty_in_middle}')

def GetChannelInfo(protocol_df):
    
    CheckEmptyDataInMiddle(protocol_df)
    
    candidates_num = (protocol_df.shape[1] - 1) / 2
    if candidates_num % 1 != 0:
        raise ValueError('The number of channel columns in the protocol file is not even. Please check status and time column pairs.')
    else:
        candidates_num = int(candidates_num)

    # get channel number and verify the format
    ch_num = 0
    for i in range(int(candidates_num)):
        # check if the column name ends with '_status' and the next column ends with '_time_[unit]'
        col_status_i = protocol_df.columns[i*2+1]
        col_time_i = protocol_df.columns[i*2+2]
        status_name_i = col_status_i.split('_')[0]
        time_name_i = col_time_i.split('_')[0]
        ch_name_i = 'CH' + str(i+1)
        
        if (not status_name_i == ch_name_i) or (not col_status_i.split('_')[-1] == 'status'):
            raise ValueError(f'Column {i*2+1} "{col_status_i}" does not match the format of continuous channel index or status assignment, which should be "{ch_name_i}_status".')
        elif (not time_name_i == ch_name_i) or (not col_time_i.split('_')[-2] == 'time'):
            raise ValueError(f'Column {i*2+2} "{col_time_i}" does not match the format of continuous channel index or time assignment, which should be "{ch_name_i}_time_[unit]".')
        else:
            ch_num += 1
    
    # get valid length of each channel
    ch_valid_length = dict()
    valid_channels = []
    for i in range(ch_num):
        ch_name = 'CH' + str(i+1)
        ch_status = protocol_df.iloc[:, i*2+1]
        ch_time = protocol_df.iloc[:, i*2+2]
        
        ch_valid_length[ch_name] = ch_status.count()
        if ch_valid_length[ch_name] != ch_time.count():
            raise ValueError(f'Channel "{ch_name}" has different length of status and time columns.')
        if ch_valid_length[ch_name] == 0:
            print(f'Channel "{ch_name}" is empty.')
        else:
            valid_channels.append(ch_name)
        
    # get channel time units
    ch_units = [protocol_df.columns[i*2+2].split('_')[-1] for i in range(ch_num)]
    for i in range(ch_num):
        if ch_units[i] in ['s', 'sec', 'second', 'seconds']:
            ch_units[i] = 'sec'
        elif ch_units[i] in ['m', 'min', 'minute', 'minutes']:
            ch_units[i] = 'min'
        elif ch_units[i] in ['h', 'hr', 'hour', 'hours']:
            ch_units[i] = 'hr'
        elif ch_units[i] in ['ms', 'msec', 'millisecond', 'milliseconds']:
            ch_units[i] = 'ms'
        else:
            raise ValueError(f'Channel time unit {ch_units[i]} is not recognized. Please use millisecond(msec, ms), second(sec, s), minute(min, m), or hour(hr, h).')
    
    return ch_units, valid_channels

def ConvertTimeToMillisecond(protocol_df, ch_units):
    df_ms = protocol_df.copy()
    
    col_names = df_ms.columns.tolist()
    for i in range(len(ch_units)):
        col_names[i*2+2] = col_names[i*2+2].split('_')[0] + '_time_ms'
    df_ms.columns = col_names
    
    for i in range(len(ch_units)):
        if ch_units[i] == 'sec':
            df_ms.iloc[:, i*2+2] = df_ms.iloc[:, i*2+2] * 1000
        elif ch_units[i] == 'min':
            df_ms.iloc[:, i*2+2] = df_ms.iloc[:, i*2+2] * 60 * 1000
        elif ch_units[i] == 'hr':
            df_ms.iloc[:, i*2+2] = df_ms.iloc[:, i*2+2] * 60 * 60 * 1000
        elif ch_units[i] == 'ms':
            pass
        else:
            raise ValueError(f'Channel time unit {ch_units[i]} is not recognized. Please use millisecond(msec, ms), second(sec, s), minute(min, m), or hour(hr, h).')
    
    df_ms = df_ms.fillna(0)
    # convert columns to integer, except the first column
    for col in df_ms.columns[1:]:
        df_ms[col] = df_ms[col].astype(int)
    
    # Check for values greater than 2^32 - 1, excluding strings
    for col in df_ms.columns:
        if df_ms[col].dtype != object and df_ms[col].max() > 2**32 - 1:
            max_val = df_ms[col].max()
            max_val_loc = df_ms[df_ms[col] == max_val].index.tolist()
            raise ValueError(f'The value {max_val} in column "{col}" is larger than the maximum value of 2^32 - 1. Please check the following rows: {max_val_loc}')
    return df_ms

def str2datetime(time_str):
    # generated by GPT 4o
    formats = ['%Y-%m-%d %H:%M', '%H:%M', '%H:%M:%S', '%Y-%m-%d %H:%M:%S']
    for fmt in formats:
        try:
            return datetime.datetime.strptime(time_str, fmt)
        except ValueError:
            continue
    raise ValueError(f"Time data '{time_str}' does not match any of the formats: {formats}")

def ReadStartTime(df_startTime):
    # check if the start time file has only two row
    if df_startTime.shape[0] != 2:
        raise ValueError('The start time file should have two rows: one for start_time and one for the wait_status.')
    
    # check if column names match 'CH' + number
    pattern = re.compile(r'CH\d+')
    for col in df_startTime.columns:
        if not pattern.match(col):
            raise ValueError(f'Column name "{col}" does not match the format of CH + i (CH1, CH2, ..., starts from CH1).')
    
    # read the start time of each channel and convert to datetime
    start_time = dict()
    wait_status = dict()
    start_time_nans = []
    wait_status_nans = []
    for col in df_startTime.columns:
        # read as string
        ch_time = df_startTime[col][0]
        ch_status = df_startTime[col][1]
        
        if pd.isna(ch_time):
            start_time[col] = None
            start_time_nans.append(col)
        elif type(ch_time) is datetime.time:
            start_time[col] = ch_time
        else:
            start_time[col] = str2datetime(str(ch_time))
        
        if pd.isna(ch_status):
            wait_status[col] = None
            wait_status_nans.append(col)
        else:
            wait_status[col] = int(bool(ch_status))
            
    if start_time_nans != wait_status_nans:
        raise ValueError(f'Incomplete start time file. A channel should have both or neither start time and wait status')
    
    # if the start time does not have date, add the date of today
    today = datetime.datetime.now().date()
    for key in start_time.keys():
        if type(start_time[key]) is datetime.time:
            start_time[key] = datetime.datetime.combine(today, start_time[key])
    
    return start_time, wait_status

def CheckStartTimeForChannels(start_time, valid_channels):
    # check if start time is missing
    missing_start_time = []
    for ch in valid_channels:
        if ch not in start_time.keys() or start_time[ch] is None:
            missing_start_time.append(ch)
    if missing_start_time:
        raise ValueError(f'Start time is missing for the following channels: {missing_start_time}')
    
    # check if start time is earlier than current time
    earlier_start_time = []
    for ch in valid_channels:
        if start_time[ch] < datetime.datetime.now():
            earlier_start_time.append(ch)
    if earlier_start_time:
        raise ValueError(f'Start time is earlier than current time for the following channels: {earlier_start_time}')

def CountDown(start_time):
    '''return the remaining time for each channel to start in milliseconds'''
    # get remaining time for each channel to start, convert to milliseconds
    remaining_time = dict()
    for ch in start_time.keys():
        if start_time[ch] is not None:
            remaining_time[ch] = int((start_time[ch] - datetime.datetime.now()).total_seconds() * 1000) 
    return remaining_time

def SendCommand(ser, command, time_out=5):
    command = str(command).strip()
    cmd_t = command + '\n'
    ser.write(cmd_t.encode('utf-8'))
    t_cmd = time.time()
    while True:
        if ser.inWaiting() > 0:
            fb = ser.readline().decode('utf-8').strip()
            if fb == command.strip():
                print(f'Python: Command "{cmd_t.strip()}" is sent successfully.')
                break
            else:
                print(f'\033[31mCommand "{cmd_t.strip()}" is not received correctly. Received "{fb}".\033[0m')
                break
        if time.time() - t_cmd > time_out:
            print(f'\033[31mCommand "{cmd_t.strip()}" is not received correctly. Timeout. Please check the connection.\033[0m')
            break

def SendGreeting(ser, time_out=5):
    greeting = 'Hello\n'
    ser.write(greeting.encode('utf-8'))
    t_greet = time.time()
    while True:
        if ser.inWaiting() > 0:
            fb = ser.readline().decode('utf-8').strip()
            if fb == 'Salve':
                print('Arduino: Salve!')
                break
            else:
                raise ValueError(f'Greeting "{greeting.strip()}" is not received correctly. Received "{fb}".')
        if time.time() - t_greet > time_out:
            raise TimeoutError(f'Greeting "{greeting.strip()}" is not received correctly. Timeout. Please check the connection.')

def SayBye(ser, time_out=5):
    bye = 'Bye\n'
    ser.write(bye.encode('utf-8'))
    t_bye = time.time()
    while True:
        if ser.inWaiting() > 0:
            fb = ser.readline().decode('utf-8').strip()
            if fb == 'Arrivederci':
                print('Arduino: Arrivederci!')
                break
            else:
                print(f'\033[31mBye "{bye.strip()}" is not received correctly. Received "{fb}".\033[0m')
                break
        if time.time() - t_bye > time_out:
            print(f'\033[31mBye "{bye.strip()}" is not received correctly. Timeout. Please check the connection.\033[0m')
            break

def MatchTime(ser, t_send=20, time_out=0):
    t_timeout = time.time()
    if time_out <= t_send:
        time_out = t_send + 5
    t_sent = int(t_send * 1e3) # convert to milliseconds
    calibrate = f'calibrate_{t_sent}\n'
    ser.write(calibrate.encode('utf-8'))
    t1 = time.time()
    time.sleep(t_send - 2)
    while True:
        if ser.inWaiting() > 0:
            t2 = time.time()
            fb = ser.readline().decode('utf-8').strip()
            if fb.startswith('calibration'):
                # print(fb)
                t_feedback = t2 - t1
                break
            else:
                print(f'\033[31mTime is not calibrated correctly. Received "{fb}".\033[0m')
                break
        if time.time() - t_timeout > time_out:
            print(f'\033[31mTime is not calibrated correctly. Timeout. Please check the connection.\033[0m')
            break
    return t_feedback

def countdown_timer(total_time, step=1):
    """
    Countdown timer that runs for the specified total time.
    """
    for remaining in range(total_time, 0, -step):
        print(f"Time remaining: {remaining} seconds     ", end="\n")
        time.sleep(step)
    print("Time's up!                           ")

def CalibrateArduinoTime(ser, t_send=None):
    '''
    Calibrate the time of Arduino
    ser: serial port
    t_send: list of time to send in seconds, default is [0, 1, 2, 5]
    '''
    if t_send is None:
        t_send = [40, 50, 60]
    elif type(t_send) is int:
        t_send = [t_send]
    
    if len(t_send) < 2:
        if t_send[0] != 40:
            t_send = [40] + t_send
    
    t_feedback = []
    t_sum = sum(t_send)
    print(f'Calibrating Arduino time.... Please wait for about {t_sum} seconds.')
    timer_thread = threading.Thread(target=countdown_timer, args=(t_sum,10,))
    timer_thread.start()
    for t in t_send:
        t_feedback_i = MatchTime(ser, t_send=t)
        t_feedback.append(t_feedback_i)
    timer_thread.join()

    # linear regression
    t_sent = np.array(t_send)
    t_feed = np.array(t_feedback)
    coefficients = np.polyfit(t_sent, t_feed, 1)
    linear_fit = np.poly1d(coefficients)
    
    # Calculate R-squared
    y_pred = linear_fit(t_send)
    ss_res = np.sum((t_feedback - y_pred) ** 2)
    ss_tot = np.sum((t_feedback - np.mean(t_feedback)) ** 2)
    r_squared = 1 - (ss_res / ss_tot)
    
    kwargs_output = {'calib_factor': coefficients[0], 'cost': coefficients[1], 'r_squared': r_squared, 't_send': t_sent, 't_feedback': t_feed}
    
    return kwargs_output

def CorrectTime_df(df_ms, calib_factor):
    df_corrected = df_ms.copy()
    for col in df_corrected.columns:
        if col.endswith('_time_ms'):
            df_corrected[col] = df_corrected[col] / calib_factor
    df_corrected = df_corrected.fillna(0)
    for col in df_corrected.columns[1:]:
        df_corrected[col] = df_corrected[col].astype(int)
    return df_corrected

def CorrectTime_dict(remaining_time, calib_factor):
    remaining_time_corrected = dict()
    for ch, t in remaining_time.items():
        remaining_time_corrected[ch] = int(t / calib_factor)
    return remaining_time_corrected

def CorrectTime(dataIn, calib_factor=1):
    if type(dataIn) is pd.DataFrame:
        return CorrectTime_df(dataIn, calib_factor)
    elif type(dataIn) is dict:
        return CorrectTime_dict(dataIn, calib_factor)
    else:
        raise ValueError('Input data type is not recognized. Please use pandas DataFrame or dictionary.')

def FindRepeatedPatterns(df_ms, pattern_length=2):
    """
    Find and compress repeated patterns across both status and time_ms for all channels.
    
    Each channel has two columns: CH[n]_status and CH[n]_time_ms.
    The status can be 0 or 1, and time_ms is the time in milliseconds.
    
    :param df_ms: pandas DataFrame containing the protocol data
    :param pattern_length: the length of the pattern to search for
    :return: a dictionary with channel names as keys and their compressed patterns as values
    """
    compressed_patterns = {}
    num_channels = int((df_ms.shape[1] - 1) / 2)
    
    for n in range(1, num_channels + 1):
        status_col = f'CH{n}_status'
        time_col = f'CH{n}_time_ms'
        
        status_data = df_ms[status_col].tolist()
        time_data = df_ms[time_col].tolist()
        
        # Combine status and time into tuples
        combined = list(zip(status_data, time_data))
        
        patterns = []
        i = 0
        while i < len(combined):
            # Extract the current pattern
            current_pattern = tuple(combined[i:i + pattern_length])
            count = 1
            j = i + pattern_length
            # Check for consecutive repeats of the current pattern
            while j + pattern_length <= len(combined) and tuple(combined[j:j + pattern_length]) == current_pattern:
                count += 1
                j += pattern_length
            patterns.append({'pattern': current_pattern, 'repeats': count})
            i = j
        compressed_patterns[f'CH{n}'] = patterns
    
    return compressed_patterns

def GeneratePatternCommands(compressed_patterns):
    '''
    Generate string commands from compressed patterns
    compressed_patterns: Dictionary containing compressed patterns for each channel, generated by FindRepeatedPatterns()
    '''
    commands = []
    for channel_name, patterns in compressed_patterns.items():
        # Extract channel number from the channel name (e.g., 'CH1' -> 1)
        channel_num = int(channel_name.replace('CH', ''))
        for i, pattern in enumerate(patterns):
            status_values = [str(s) for s, t in pattern['pattern']]
            time_values = [str(t) for s, t in pattern['pattern']]
            repeats = pattern['repeats']
            # if the status_values are all 0, time_values are all 0, skip
            if all([s == '0' for s in status_values]) and all([t == '0' for t in time_values]):
                continue
            # Construct the command string
            cmd_t = \
                f"PATTERN:{i+1};CH:{channel_num};STATUS:{','.join(status_values)};" \
                f"TIME_MS:{','.join(time_values)};REPEATS:{repeats}\n"
            commands.append(cmd_t)
    return commands

def GenerateWaitCommands(wait_status, remaining_time, valid_channels):
    '''
    Generate string commands for waiting for each channel to start
    wait_status: Dictionary containing wait status for each channel
    remaining_time: Dictionary containing remaining time for each channel to start in milliseconds
    return -> List of string commands, one for each channel
    for example: ['PATTERN:0;CH:1;STATUS:1,0;TIME_MS:1000,0;REPEATS:1\n', ...]
    '''
    commands = []
    for channel_name in valid_channels:
        channel_num = int(channel_name.replace('CH', ''))
        status = wait_status[channel_name]
        if status is None:
            continue
        cmd_t = \
            f"PATTERN:0;CH:{channel_num};STATUS:{status},0;" \
            f"TIME_MS:{remaining_time[channel_name]},0;REPEATS:1\n"
        commands.append(cmd_t)
    return commands

def ReadExcelFile(file_path):
    '''
    Read the protocol file in Excel format
    file_path: path to the Excel file
    return -> pandas DataFrame
    '''
    excel_file = pd.ExcelFile(file_path)
    sheet_names = excel_file.sheet_names
    if 'protocol' in sheet_names:
        df_protocol = excel_file.parse('protocol', header=0, index_col=None)
    else:
        raise ValueError('Sheet "protocol" is not found in the Excel file.')
    if 'start_time' in sheet_names:
        df_startTime = excel_file.parse('start_time', header=0, index_col=0)
    else:
        raise ValueError('Sheet "start_time" is not found in the Excel file.')
    if 'calibration' in sheet_names:
        df_calibration = excel_file.parse('calibration', header=0, index_col=None)
        if df_calibration.shape[0] > 1:
            raise ValueError('The calibration sheet should have only one row.')
        elif df_calibration.shape[0] == 1:
            calib_factor = df_calibration.iloc[0, 0]
            if pd.isna(calib_factor):
                calib_factor = None
            elif calib_factor <= 0:
                raise ValueError('Calibration factor should be positive.')
        else:
            calib_factor = None
    else:
        calib_factor = None
    if calib_factor is not None:
        print(f'Read calibration factor: {calib_factor}')
    return df_protocol, df_startTime, calib_factor